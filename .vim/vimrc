""""""""""""""""""""""""""""""""""
" CuongLM aka Gnouc's vimrc file "
""""""""""""""""""""""""""""""""""

source $HOME/.vim/vimrc_bundle

" Set 'nocompatible' to ward off unexpected things that your distro might
" have made, as well as sanely reset options when re-sourcing .vimrc
set nocompatible

" Set background
if has("gui_running")
    set background=dark
else
    set background=light
endif

" Syntax highlighting
syntax enable

" Set encoding
set encoding=utf-8

" Set colorscheme
"colorscheme desert
"colorscheme pyte
"colorscheme grb256
"colorscheme vividchalk
let g:solarized_termcolors = 256
let g:solarized_termtrans  = 0
let g:solarized_degrade    = 0
let g:solarized_bold       = 1
let g:solarized_underline  = 1
let g:solarized_italic     = 1
let g:solarized_contrast   = "normal"
let g:solarized_visibility = "normal"
let g:solarized_hitrail    = 0
let g:solarized_menu       = 1
call togglebg#map("<C-b>")
colorscheme solarized
"colorscheme distinguished
"colorscheme developer
"colorscheme tidy

" Fix color in tmux
if &term =~ '256color'
  set t_ut=
endif

" Enable file type detection
if has("autocmd")
    filetype plugin indent on
endif

" Do smart autoindenting when starting a new line
set smartindent

" Show matched pattern when search
set incsearch

" Highlight mathed pattern
set hlsearch

" Ignore case of normal letter
set ignorecase

" Override the 'ignorecase' option if
" the search pattern contains upper case characters
set smartcase

" Smart with tab
set smarttab

" Show line and column of cursor position
set ruler

" Show command
set showcmd

" Complete longest common string, then each full match
set wildmode=longest:full
set wildmenu

" Adding character form pairs
set matchpairs+=<:>

" Number of space that <Tab> count
set tabstop=4

" In Insert mode: Use the appropriate number of spaces to insert a <Tab>
set expandtab

" Number of spaces to use for each step of (auto)indent)
set shiftwidth=4

" Round indent to multiple of 'shiftwidth'
set shiftround

" Don't wrap long line
set nowrap

" Allow backspace over anything
set backspace=indent,eol,start

" Show full path file
set laststatus=2
set statusline=%<\ %F\ %m%r-\ FileType:\ %y%=%-35.(line:\ %l\ of\ %L,\ col:\ %c%V\ (%P)%)

" List tree view
let g:netrw_liststyle=3
let g:netrw_browse_split=3

" NerdTree
nnoremap <C-n> :NERDTreeToggle<CR>
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

" Highlight trailing white spaces
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Set backup
if has("vms")
    set nobackup
else
    set backup
endif

set backupdir=~/.vim/backup/
set dir=~/.vim/backup/

" Back to last edited line
if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

" Turn off highlight search in insert mode
augroup hlsearch
    autocmd!
    autocmd InsertEnter * :setlocal nohlsearch
    autocmd InsertLeave * :setlocal hlsearch
augroup END

" Show help full screen
autocmd FileType help only

" Open help in new tab
cabbrev help tab help
cabbrev h tab h

" Don't add comment automatically
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

" Use system clipboard
set clipboard=unnamedplus

" Show long line indicator
if v:version >= 703
    augroup colorcolumn
        autocmd!
        autocmd FileType python setlocal colorcolumn=78
        autocmd FileType c setlocal colorcolumn=80
        autocmd FileType cpp setlocal colorcolumn=80
        autocmd FileType perl setlocal colorcolumn=100
    augroup END
endif

" Salt state files
augroup sls
    autocmd!
    " Function to setting sls file
    function Slsconfig()
        if getline(1) =~# '\v^#!py(dsl|)$'
            set filetype=python
            setlocal tabstop=4
            setlocal shiftwidth=4
        else
            set filetype=yaml
            setlocal tabstop=2
            setlocal shiftwidth=2
        endif
    endfunction

    autocmd BufRead,BufNewFile *.sls call Slsconfig()
augroup END

" Python
fun Python_config()
    NeoBundleSource vim-python-pep8-indent
    let g:pydiction_location = '~/.vim/bundle/pydiction/complete-dict'
    let g:jedi#popup_on_dot = 0
endf
autocmd Filetype python :call Python_config()

" Javascript
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS

" HTML
autocmd FileType html,markdown set omnifunc=htmlcomplete#CompleteTags

" PHP
autocmd FileType php set omnifunc=phpcomplete#CompletePHP

" Haskell
autocmd FileType haskell set omnifunc=necoghc#omnifunc
let g:necoghc_enable_detailed_browse = 1

" Lua
fun Lua_config()
    let g:lua_safe_omni_modules = 0
    let g:lua_define_omnifunc = 0
    let g:lua_complete_omni = 0
endf
autocmd Filetype lua :call Lua_config()

" YouCompleteMe
"let g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'

" NeoCompleteCache
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" Enable heavy features.
" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
"autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
"autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
"autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
"autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
"autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" supertab
let g:SuperTabDefaultCompletionType = "context"
set completeopt=menuone,longest,preview

" Ack
nmap \a <Esc>:Ack!

" JSON format
command Json execute "%!python -m json.tool"

"""""""""""""
" bind keys "
"""""""""""""

map \c i{<Esc>ea}<Esc>
map \p i(<Esc>ea)<Esc>
map \q i'<Esc>ea'<Esc>
map \dq i"<Esc>ea"<Esc>
map \C :%s///gn<CR>

inoremap jk <Esc>
nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>
nnoremap <silent> <F3> :set cuc! cul!<CR>
nnoremap <silent> <F4> :set nu!<CR>
nnoremap <silent> <F5> :Texplore<CR>
set pastetoggle=<F2>

inoremap {      {}<Left>
inoremap {<CR>  {<CR>}<Esc>O
inoremap {;<CR>  {<CR>};<Esc>O
inoremap {{     {
inoremap {}     {}

inoremap [      []<Left>
inoremap [<CR>  [<CR>]<Esc>O
inoremap [[     [
inoremap []     []

inoremap (      ()<Left>
inoremap (<CR>  (<CR>)<Esc>O
inoremap (;<CR>  (<CR>);<Esc>O
inoremap ((     (
inoremap ()     ()

nnoremap \s :up!<CR>

" remap keys to move around the windows
map <c-j> <c-w>j
map <c-k> <c-w>k
map <c-l> <c-w>l
map <c-h> <c-w>h

" long lines as break lines
map j gj
map k gk

" save file with sudo
cmap w!! w !sudo tee > /dev/null %

" toggle Gundo window
map \g :GundoToggle<CR>

" pep8_map
let g:pep8_map='\8'

" Do not use arrow keys
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>

nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>

""""""""""""""""""
" Custom tabline "
""""""""""""""""""
set tabline=%!MyTabLine()
function MyTabLine()
    let s = '' " complete tabline goes here
    " loop through each tab page
    for t in range(tabpagenr('$'))
        " set highlight
        if t + 1 == tabpagenr()
            let s .= '%#TabLineSel#'
        else
            let s .= '%#TabLine#'
        endif
        " set the tab page number (for mouse clicks)
        let s .= '%' . (t + 1) . 'T'
        let s .= ' '
        " set page number string
        let s .= t + 1 . ' '
        " get buffer names and statuses
        let n = ''      "temp string for buffer names while we loop and check buftype
        let m = 0       " &modified counter
        let bc = len(tabpagebuflist(t + 1))     "counter to avoid last ' '
        " loop through each buffer in a tab
        for b in tabpagebuflist(t + 1)
            " buffer types: quickfix gets a [Q], help gets [H]{base fname}
            " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
            if getbufvar( b, "&buftype" ) == 'help'
                 let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
            elseif getbufvar( b, "&buftype" ) == 'quickfix'
                 let n .= '[Q]'
            else
                 let n .= pathshorten(bufname(b))
            endif
            " check and ++ tab's &modified count
            if getbufvar( b, "&modified" )
                 let m += 1
            endif
            " no final ' ' added...formatting looks better done later
            if bc > 1
                 let n .= ' '
            endif
            let bc -= 1
        endfor
        " add modified label [n+] where n pages in tab are modified
        if m > 0
             let s .= '[' . m . '+]'
        endif
        " select the highlighting for the buffer names
        " my default highlighting only underlines the active tab
        " buffer names.
        if t + 1 == tabpagenr()
             let s .= '%#TabLineSel#'
        else
             let s .= '%#TabLine#'
        endif
        " add buffer names
        if n == ''
             let s.= '[New]'
        else
             let s .= n
        endif
        " switch to no underlining and add final space to buffer list
        let s .= ' '
    endfor
    " after the last tab fill with TabLineFill and reset tab page nr
    let s .= '%#TabLineFill#%T'
    " right-align the label to close the current tab page
    if tabpagenr('$') > 1
         let s .= '%=%#TabLineFill#%999Xclose'
    endif
    return s
endfunction

""""""""""""""""""""""""""""""""
"Tab Completion in Insert Mode "
""""""""""""""""""""""""""""""""

function! Tab_Or_Complete()
  if col('.') > 1 && strpart( getline('.'), col('.') - 2, 3 ) =~ '^\w'
    return "\<C-N>"
  else
    return "\<Tab>"
  endif
endfunction
inoremap <Tab> <C-R>=Tab_Or_Complete()<CR>

"""""""""""""""""""""""""""
"Auto highlight variables "
"""""""""""""""""""""""""""

" Vawa Plugin for VIM > 7.3 version 1.00
" Maintainer: Sandeep.c.r<sandeepcr2@gmail.com>
" Hacked for Perl by Curtis "Ovid" Poe <ovid@allaroundtheworld.fr>
 
function! s:vawa()
    call clearmatches()
    let s:temp          = getpos('.')
    let s:current_col   = s:temp[2]
    let s:current_line  = s:temp[1]
    let s:temp          = searchpos('[>$@%*&]','bcn')
    let s:sigil_line    = s:temp[0]
    let s:sigil_col     = s:temp[1]
    if(s:sigil_line != s:current_line)
        return
    endif
    let s:temp = getbufline(bufnr('%'),line('.'))
    let s:varend = match(s:temp[0], '[^a-zA-Z0-9_\x7f-\xff]\|\n', s:sigil_col)+1
    let s:space_col = s:varend
    if((s:space_col > s:sigil_col) && ( s:space_col< s:current_col))
        return
    endif
    if(s:varend == 0)
        let s:varend = strlen(s:temp[0])+1
    endif
    let s:current_char = s:temp[0][s:current_col-1]
    if(s:current_char == '>' || s:current_char == '-')
        return
    endif
    if(exists("g:vawahl"))
        exe "highlight VarHl  " . g:vawahl
    else
        highlight VarHl  ctermbg=black ctermfg=red guifg=#ff0000 guibg=#000000 ctermfg=LightRed gui=bold
    endif
    let s:str = strpart(s:temp[0], s:sigil_col-1,(s:varend - s:sigil_col))
    let s:prefix = ''
    if(exists("g:vawanohlcurrent") && (g:vawanohlcurrent == 1))
        let s:lineab = s:current_line - 1
        let s:linebe = s:current_line + 1
        let s:colbf  = s:sigil_col + 1
        let s:prefix = '\(\%>'.s:lineab.'l.\%<'.s:linebe.'l.\%>'.s:colbf.'c\)\@!'
    endif
    if(s:str == '$')
        return
    endif
    if(strpart(s:str,0,1) == '>')
        let s:str = strpart(s:str ,1)
        call matchadd('VarHl', s:prefix.'>\@<='. s:str.'\n\{-\}\(\([^a-zA-Z0-9_\x7f-\xff]\)\|$\)\@=')
    else
        call matchadd('VarHl', s:prefix.s:str.'\n\{-\}\(\([^a-zA-Z0-9_\x7f-\xff]\)\|$\)\@=')
    endif
endfunction
if(!exists("g:vawanoauto") || (g:vawanoauto == 1))
    augroup HighlightVar
            autocmd!
            au CursorMoved  *.pl call <sid>vawa()
            au CursorMovedi *.pl call <sid>vawa()
            au CursorMoved  *.pm call <sid>vawa()
            au CursorMovedi *.pm call <sid>vawa()
            au CursorMoved  *.t  call <sid>vawa()
            au CursorMovedi *.t  call <sid>vawa()
    augroup END
endif

command! Vawa :call <sid>vawa()
